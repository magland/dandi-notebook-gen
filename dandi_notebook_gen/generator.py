"""
Python script generator for Dandisets using jupytext format and AI completion
"""

import os
import re
import datetime
from pathlib import Path
from typing import List, Dict, Any, Tuple, Optional

from .run_completion import run_completion
from .script_runner import preprocess_and_run_script

def read_system_prompt() -> str:
    """
    Read the system prompt from the markdown file.

    Returns
    -------
    str
        The system prompt content.
    """
    prompt_path = Path(__file__).parent / "system_prompt.md"
    with open(prompt_path, 'r') as f:
        return f.read()

def clean_content(content: str) -> str:
    """
    Clean the AI-generated content by extracting the Python code between <python_code> tags.
    Also removes any result tags if present.

    Parameters
    ----------
    content : str
        The content generated by the AI.

    Returns
    -------
    str
        The cleaned content containing only the Python code.
    """
    # Extract content between <python_code> and </python_code> tags if present
    python_code_match = re.search(r'<python_code>\s*(.*?)\s*</python_code>', content, re.DOTALL)
    if python_code_match:
        content = python_code_match.group(1)
        # Only remove result tags if they're not inside python_code tags
        return content
    else:
        # Remove <result> and </result> tags if present (for backward compatibility)
        content = re.sub(r'<result>\s*', '', content)
        content = re.sub(r'\s*</result>', '', content)
        return content

def generate_notebook(dandiset_id: str, output_path=None, model="anthropic/claude-3-opus:beta", log_dir="logs", log_file=None):
    """
    Generate a Python script in jupytext format for exploring a Dandiset.

    Parameters
    ----------
    dandiset_id : str
        The ID of the Dandiset to generate a notebook for.
    output_path : str, optional
        Path where the script should be saved. If None, a default path will be used.
    model : str, optional
        The AI model to use for generating the notebook content.
    log_dir : str, optional
        Directory where log files will be stored. Default is "logs".
    log_file : str, optional
        Name of the log file. If None, a timestamped filename will be generated.

    Returns
    -------
    str
        Path to the generated script.
    """
    # Determine the output path
    if output_path is None:
        output_path = f"dandiset_{dandiset_id}_exploration.py"

    # Read the system prompt
    system_prompt = read_system_prompt()

    # Create messages for the AI
    messages = [
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": f"Generate a Jupytext format Python script for exploring Dandiset {dandiset_id}. The script should help researchers understand and analyze the data in this dataset. Use the available tools to gather information about the dataset and create a comprehensive exploration notebook."}
    ]

    print(f"Generating notebook for Dandiset {dandiset_id}...")

    # Prepare metadata for logging
    metadata = {
        "dandiset_id": dandiset_id,
        "output_path": output_path,
        "timestamp": datetime.datetime.now().isoformat()
    }

    # Initialize attempt counter
    attempt_count = 0
    max_attempts = 4

    while attempt_count < max_attempts:
        attempt_count += 1
        print(f"Attempt {attempt_count} of {max_attempts}")
        # Run the AI completion
        content, new_messages, prompt_tokens, completion_tokens = run_completion(
            messages=messages,
            model=model,
            log_dir=log_dir,
            log_file=log_file,
            metadata=metadata
        )

        print(f"Notebook content generated. Tokens used: {prompt_tokens} prompt, {completion_tokens} completion")

        # Clean the AI-generated content
        cleaned_content = clean_content(content)

        # Ensure the directory exists
        os.makedirs(os.path.dirname(output_path) if os.path.dirname(output_path) else '.', exist_ok=True)

        # Write the script to a file
        with open(output_path, 'w') as f:
            f.write(cleaned_content)

        # Always run the script after generation
        success, output, error = run_generated_script(output_path)
        if not success and error:
            print(f"Error running script: {error}")
            content = f"The following error has occurred. {error}"
            new_user_message = {
                "role": "user",
                "content": content
            }
            messages = new_messages + [ new_user_message ]
            # If we've reached max attempts, break out of the loop
            if attempt_count >= max_attempts:
                print(f"Maximum number of attempts ({max_attempts}) reached. Stopping with the last generated script.")
        else:
            break

    return output_path


def run_generated_script(script_path: str) -> Tuple[bool, Optional[str], Optional[str]]:
    """
    Run a generated script with preprocessing for matplotlib plots.
    If the script fails, it will print an error message and send another user message.

    Parameters
    ----------
    script_path : str
        Path to the script to run.

    Returns
    -------
    Tuple[bool, Optional[str], Optional[str]]
        A tuple containing:
        - success: True if the script ran successfully, False otherwise.
        - output: The standard output of the script if available, None otherwise.
        - error: The standard error of the script if it failed, None otherwise.
    """
    print(f"Running script: {script_path}")
    success, output, error = preprocess_and_run_script(script_path, capture_output=True)

    return success, output, error
